// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
)

func main() {
	var txtPath, outPath string
	flag.StringVar(&txtPath, "txt", "", "path of file containing English text")
	flag.StringVar(&outPath, "o", "", "path of output file")
	flag.Parse()

	if err := run(txtPath, outPath); err != nil {
		log.Fatal(err)
	}
}

func run(txtPath, outPath string) error {
	counts := make([]int, 256)
	block := make([]byte, 8192)
	var size int64

	r, err := os.Open(txtPath)
	if err != nil {
		return err
	}
	defer r.Close()
	for {
		n, err := r.Read(block)
		for _, b := range block[:n] {
			counts[int(b)]++
		}
		size += int64(n)
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}
	}
	fmt.Fprintf(os.Stderr, "read %d bytes\n", size)
	for i, c := range counts {
		fmt.Fprintf(os.Stderr, "%3d: %6d\n", i, c)
	}

	freqs := make([]float64, 256)
	for i, c := range counts {
		freqs[i] = float64(c) / float64(size)
		// fmt.Fprintf(os.Stderr, "%3d: %6d / %6d = %f\n", i, c, size, freqs[i])
	}

	buf := &bytes.Buffer{}
	fmt.Fprint(buf, `// Code generated by genfreq.go. DO NOT EDIT.

package crypto

var EnglishFreqs = [256]float64{
`)
	for _, f := range freqs {
		fmt.Fprintf(buf, "\t%g,\n", f)
	}
	fmt.Fprint(buf, "}\n")
	return ioutil.WriteFile(outPath, buf.Bytes(), 0666)
}
